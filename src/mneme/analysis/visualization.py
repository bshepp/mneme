"""Visualization utilities for field analysis results."""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.colors import LinearSegmentedColormap
from typing import Dict, List, Any, Optional, Tuple, Union
import warnings

from ..types import Field, PersistenceDiagram, Attractor, AnalysisResult


class FieldVisualizer:
    """Visualize fields and analysis results."""
    
    def __init__(self, style: str = 'publication', figsize: Tuple[int, int] = (10, 8)):
        """
        Initialize field visualizer.
        
        Parameters
        ----------
        style : str
            Plotting style preset
        figsize : Tuple[int, int]
            Default figure size
        """
        self.style = style
        self.figsize = figsize
        self.setup_style()
    
    def setup_style(self):
        """Setup matplotlib style."""
        if self.style == 'publication':
            plt.style.use('seaborn-v0_8-whitegrid')
            plt.rcParams.update({
                'font.size': 12,
                'axes.labelsize': 14,
                'axes.titlesize': 16,
                'xtick.labelsize': 12,
                'ytick.labelsize': 12,
                'legend.fontsize': 12,
                'figure.titlesize': 18,
                'axes.spines.top': False,
                'axes.spines.right': False,
                'figure.dpi': 300
            })
        elif self.style == 'presentation':
            plt.style.use('seaborn-v0_8-talk')
            plt.rcParams.update({
                'font.size': 14,
                'figure.dpi': 150
            })
    
    def plot_field(
        self,
        field: Union[Field, np.ndarray],
        title: Optional[str] = None,
        colormap: str = 'viridis',
        show_colorbar: bool = True,
        ax: Optional[plt.Axes] = None,
        **kwargs
    ) -> plt.Figure:
        """
        Plot 2D field with customizable appearance.
        
        Parameters
        ----------
        field : Field or np.ndarray
            Field to plot
        title : str, optional
            Plot title
        colormap : str
            Colormap name
        show_colorbar : bool
            Whether to show colorbar
        ax : plt.Axes, optional
            Existing axes to plot on
        **kwargs
            Additional arguments for imshow
            
        Returns
        -------
        fig : plt.Figure
            Figure object
        """
        if ax is None:\n            fig, ax = plt.subplots(figsize=self.figsize)\n        else:\n            fig = ax.get_figure()\n        \n        # Extract data\n        if isinstance(field, Field):\n            data = field.data\n            metadata = field.metadata or {}\n        else:\n            data = field\n            metadata = {}\n        \n        # Handle 3D data (take first slice)\n        if data.ndim == 3:\n            data = data[0]\n            if title is None:\n                title = \"Field (first time slice)\"\n        \n        # Plot field\n        im = ax.imshow(data, cmap=colormap, aspect='auto', **kwargs)\n        \n        if title:\n            ax.set_title(title)\n        \n        # Add colorbar\n        if show_colorbar:\n            cbar = plt.colorbar(im, ax=ax)\n            if 'units' in metadata:\n                cbar.set_label(metadata['units'])\n        \n        # Set labels\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        return fig\n    \n    def plot_field_sequence(\n        self,\n        fields: Union[List[Field], np.ndarray],\n        fps: int = 10,\n        title: Optional[str] = None,\n        colormap: str = 'viridis',\n        **kwargs\n    ) -> animation.FuncAnimation:\n        \"\"\"Create animation of field evolution.\"\"\"\n        if isinstance(fields, np.ndarray):\n            if fields.ndim != 3:\n                raise ValueError(\"Field sequence must be 3D (time, height, width)\")\n            field_data = fields\n        else:\n            field_data = np.stack([f.data for f in fields])\n        \n        fig, ax = plt.subplots(figsize=self.figsize)\n        \n        # Set up the plot\n        vmin, vmax = np.percentile(field_data, [1, 99])\n        im = ax.imshow(field_data[0], cmap=colormap, vmin=vmin, vmax=vmax, **kwargs)\n        \n        if title:\n            ax.set_title(title)\n        \n        plt.colorbar(im, ax=ax)\n        \n        def animate(frame):\n            im.set_array(field_data[frame])\n            ax.set_title(f\"{title or 'Field Evolution'} - Frame {frame}\")\n            return [im]\n        \n        ani = animation.FuncAnimation(\n            fig, animate, frames=len(field_data),\n            interval=1000//fps, blit=True\n        )\n        \n        return ani\n    \n    def plot_persistence_diagram(\n        self,\n        diagram: PersistenceDiagram,\n        ax: Optional[plt.Axes] = None,\n        title: Optional[str] = None,\n        **kwargs\n    ) -> plt.Figure:\n        \"\"\"Plot topological persistence diagram.\"\"\"\n        if ax is None:\n            fig, ax = plt.subplots(figsize=self.figsize)\n        else:\n            fig = ax.get_figure()\n        \n        if len(diagram.points) == 0:\n            ax.text(0.5, 0.5, 'No persistent features', \n                   transform=ax.transAxes, ha='center', va='center')\n            ax.set_title(title or f\"Persistence Diagram (Dim {diagram.dimension})\")\n            return fig\n        \n        # Plot points\n        birth = diagram.points[:, 0]\n        death = diagram.points[:, 1]\n        \n        # Color by persistence\n        persistence = death - birth\n        scatter = ax.scatter(birth, death, c=persistence, cmap='viridis', **kwargs)\n        \n        # Add diagonal line\n        lims = [min(birth.min(), death.min()), max(birth.max(), death.max())]\n        ax.plot(lims, lims, 'k--', alpha=0.5, label='y=x')\n        \n        # Labels and title\n        ax.set_xlabel('Birth')\n        ax.set_ylabel('Death')\n        ax.set_title(title or f\"Persistence Diagram (Dim {diagram.dimension})\")\n        \n        # Colorbar\n        plt.colorbar(scatter, ax=ax, label='Persistence')\n        \n        # Equal aspect ratio\n        ax.set_aspect('equal')\n        \n        return fig\n    \n    def plot_multiple_persistence_diagrams(\n        self,\n        diagrams: List[PersistenceDiagram],\n        titles: Optional[List[str]] = None\n    ) -> plt.Figure:\n        \"\"\"Plot multiple persistence diagrams.\"\"\"\n        n_diagrams = len(diagrams)\n        cols = min(3, n_diagrams)\n        rows = (n_diagrams + cols - 1) // cols\n        \n        fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 5*rows))\n        \n        if n_diagrams == 1:\n            axes = [axes]\n        elif rows == 1:\n            axes = axes.flatten()\n        else:\n            axes = axes.flatten()\n        \n        for i, diagram in enumerate(diagrams):\n            title = titles[i] if titles else f\"Dimension {diagram.dimension}\"\n            self.plot_persistence_diagram(diagram, ax=axes[i], title=title)\n        \n        # Hide unused subplots\n        for i in range(n_diagrams, len(axes)):\n            axes[i].set_visible(False)\n        \n        plt.tight_layout()\n        return fig\n    \n    def plot_attractor_portrait(\n        self,\n        trajectory: np.ndarray,\n        attractors: List[Attractor],\n        ax: Optional[plt.Axes] = None,\n        title: Optional[str] = None\n    ) -> plt.Figure:\n        \"\"\"Plot phase space with detected attractors.\"\"\"\n        if ax is None:\n            fig, ax = plt.subplots(figsize=self.figsize)\n        else:\n            fig = ax.get_figure()\n        \n        # Plot trajectory\n        if trajectory.shape[1] >= 2:\n            ax.plot(trajectory[:, 0], trajectory[:, 1], 'gray', alpha=0.3, linewidth=0.5)\n            ax.scatter(trajectory[:, 0], trajectory[:, 1], c='lightgray', s=1, alpha=0.5)\n        \n        # Plot attractors\n        colors = plt.cm.Set1(np.linspace(0, 1, len(attractors)))\n        \n        for i, attractor in enumerate(attractors):\n            if attractor.trajectory_indices:\n                # Plot attractor points\n                attractor_points = trajectory[attractor.trajectory_indices]\n                if attractor_points.shape[1] >= 2:\n                    ax.scatter(\n                        attractor_points[:, 0], attractor_points[:, 1],\n                        c=[colors[i]], s=20, alpha=0.8,\n                        label=f\"{attractor.type.value} (size: {attractor.basin_size:.2f})\"\n                    )\n                    \n                    # Mark center\n                    if len(attractor.center) >= 2:\n                        ax.scatter(\n                            attractor.center[0], attractor.center[1],\n                            c=[colors[i]], s=100, marker='x', linewidth=3\n                        )\n        \n        ax.set_xlabel('Dimension 1')\n        ax.set_ylabel('Dimension 2')\n        ax.set_title(title or 'Phase Space Portrait')\n        \n        if attractors:\n            ax.legend()\n        \n        return fig\n    \n    def plot_field_statistics(\n        self,\n        field: Union[Field, np.ndarray],\n        ax: Optional[plt.Axes] = None\n    ) -> plt.Figure:\n        \"\"\"Plot field statistics.\"\"\"\n        if ax is None:\n            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n        else:\n            fig = ax.get_figure()\n            ax1 = ax2 = ax\n        \n        # Extract data\n        if isinstance(field, Field):\n            data = field.data\n        else:\n            data = field\n        \n        # Flatten data for histogram\n        flat_data = data.flatten()\n        finite_data = flat_data[np.isfinite(flat_data)]\n        \n        # Histogram\n        ax1.hist(finite_data, bins=50, alpha=0.7, edgecolor='black')\n        ax1.set_xlabel('Value')\n        ax1.set_ylabel('Frequency')\n        ax1.set_title('Value Distribution')\n        \n        # Add statistics text\n        stats_text = f\"Mean: {np.mean(finite_data):.3f}\\n\"\n        stats_text += f\"Std: {np.std(finite_data):.3f}\\n\"\n        stats_text += f\"Min: {np.min(finite_data):.3f}\\n\"\n        stats_text += f\"Max: {np.max(finite_data):.3f}\"\n        \n        ax1.text(0.02, 0.98, stats_text, transform=ax1.transAxes,\n                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))\n        \n        # Spatial profile (if 2D)\n        if data.ndim == 2:\n            # Average profiles\n            profile_x = np.mean(data, axis=0)\n            profile_y = np.mean(data, axis=1)\n            \n            ax2.plot(profile_x, label='X profile')\n            ax2.plot(profile_y, label='Y profile')\n            ax2.set_xlabel('Position')\n            ax2.set_ylabel('Average Value')\n            ax2.set_title('Spatial Profiles')\n            ax2.legend()\n        \n        return fig\n    \n    def plot_reconstruction_comparison(\n        self,\n        original: Union[Field, np.ndarray],\n        reconstructed: Union[Field, np.ndarray],\n        uncertainty: Optional[np.ndarray] = None\n    ) -> plt.Figure:\n        \"\"\"Compare original and reconstructed fields.\"\"\"\n        n_plots = 3 if uncertainty is not None else 2\n        fig, axes = plt.subplots(1, n_plots, figsize=(5*n_plots, 5))\n        \n        # Extract data\n        if isinstance(original, Field):\n            orig_data = original.data\n        else:\n            orig_data = original\n        \n        if isinstance(reconstructed, Field):\n            recon_data = reconstructed.data\n        else:\n            recon_data = reconstructed\n        \n        # Plot original\n        im1 = axes[0].imshow(orig_data, cmap='viridis', aspect='auto')\n        axes[0].set_title('Original')\n        plt.colorbar(im1, ax=axes[0])\n        \n        # Plot reconstructed\n        im2 = axes[1].imshow(recon_data, cmap='viridis', aspect='auto')\n        axes[1].set_title('Reconstructed')\n        plt.colorbar(im2, ax=axes[1])\n        \n        # Plot uncertainty if available\n        if uncertainty is not None:\n            im3 = axes[2].imshow(uncertainty, cmap='Reds', aspect='auto')\n            axes[2].set_title('Uncertainty')\n            plt.colorbar(im3, ax=axes[2])\n        \n        plt.tight_layout()\n        return fig\n    \n    def create_analysis_dashboard(\n        self,\n        result: AnalysisResult,\n        save_path: Optional[str] = None\n    ) -> plt.Figure:\n        \"\"\"Create comprehensive analysis dashboard.\"\"\"\n        fig = plt.figure(figsize=(16, 12))\n        \n        # Create grid layout\n        gs = fig.add_gridspec(3, 4, hspace=0.3, wspace=0.3)\n        \n        # Original field\n        ax1 = fig.add_subplot(gs[0, 0])\n        if result.raw_data is not None:\n            self.plot_field(result.raw_data, title=\"Original Field\", ax=ax1)\n        \n        # Processed field\n        ax2 = fig.add_subplot(gs[0, 1])\n        if result.processed_data is not None:\n            self.plot_field(result.processed_data, title=\"Processed Field\", ax=ax2)\n        \n        # Reconstructed field\n        ax3 = fig.add_subplot(gs[0, 2])\n        if result.reconstruction is not None:\n            self.plot_field(result.reconstruction.field, title=\"Reconstructed Field\", ax=ax3)\n        \n        # Reconstruction uncertainty\n        ax4 = fig.add_subplot(gs[0, 3])\n        if result.reconstruction is not None and result.reconstruction.uncertainty is not None:\n            im = ax4.imshow(result.reconstruction.uncertainty, cmap='Reds', aspect='auto')\n            ax4.set_title(\"Reconstruction Uncertainty\")\n            plt.colorbar(im, ax=ax4)\n        \n        # Persistence diagrams\n        if result.topology is not None and result.topology.diagrams:\n            for i, diagram in enumerate(result.topology.diagrams[:3]):\n                ax = fig.add_subplot(gs[1, i])\n                self.plot_persistence_diagram(diagram, ax=ax)\n        \n        # Attractor analysis\n        if result.attractors:\n            ax_attr = fig.add_subplot(gs[2, :2])\n            \n            # Create simple trajectory for visualization\n            if result.processed_data is not None and result.processed_data.data.ndim == 3:\n                # Create trajectory from field evolution\n                field_data = result.processed_data.data\n                trajectory = field_data.reshape(field_data.shape[0], -1)\n                \n                # Subsample for visualization\n                if trajectory.shape[1] > 100:\n                    indices = np.random.choice(trajectory.shape[1], 100, replace=False)\n                    trajectory = trajectory[:, indices]\n                \n                self.plot_attractor_portrait(trajectory, result.attractors, ax=ax_attr)\n        \n        # Statistics\n        ax_stats = fig.add_subplot(gs[2, 2:])\n        if result.raw_data is not None:\n            self.plot_field_statistics(result.raw_data, ax=ax_stats)\n        \n        # Add title\n        fig.suptitle(f\"Analysis Dashboard - {result.experiment_id}\", fontsize=16)\n        \n        if save_path:\n            plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        \n        return fig\n    \n    def plot_pipeline_results(\n        self,\n        results: Dict[str, Any],\n        save_path: Optional[str] = None\n    ) -> plt.Figure:\n        \"\"\"Plot pipeline stage results.\"\"\"\n        fig, axes = plt.subplots(2, 2, figsize=(12, 10))\n        axes = axes.flatten()\n        \n        # Quality metrics\n        if 'quality_check' in results:\n            quality = results['quality_check']\n            metrics = quality.get('metrics', {})\n            \n            # Plot quality metrics\n            metric_names = []\n            metric_values = []\n            \n            for key, value in metrics.items():\n                if isinstance(value, (int, float)):\n                    metric_names.append(key)\n                    metric_values.append(value)\n            \n            if metric_names:\n                axes[0].bar(range(len(metric_names)), metric_values)\n                axes[0].set_xticks(range(len(metric_names)))\n                axes[0].set_xticklabels(metric_names, rotation=45, ha='right')\n                axes[0].set_title('Quality Metrics')\n        \n        # Topology features\n        if 'topology' in results:\n            topo = results['topology']\n            if 'feature_vector_length' in topo:\n                axes[1].text(0.5, 0.5, f\"Topological Features: {topo['feature_vector_length']}\",\n                           transform=axes[1].transAxes, ha='center', va='center')\n            axes[1].set_title('Topology Analysis')\n        \n        # Attractor summary\n        if 'attractors' in results:\n            attr = results['attractors']\n            if 'attractor_types' in attr:\n                types = attr['attractor_types']\n                unique_types, counts = np.unique(types, return_counts=True)\n                axes[2].bar(unique_types, counts)\n                axes[2].set_title('Attractor Types')\n                axes[2].set_xlabel('Type')\n                axes[2].set_ylabel('Count')\n        \n        # Execution times\n        times = []\n        labels = []\n        \n        for stage_name, stage_result in results.items():\n            if isinstance(stage_result, dict) and 'computation_time' in stage_result:\n                times.append(stage_result['computation_time'])\n                labels.append(stage_name)\n        \n        if times:\n            axes[3].bar(labels, times)\n            axes[3].set_title('Stage Execution Times')\n            axes[3].set_ylabel('Time (s)')\n            axes[3].tick_params(axis='x', rotation=45)\n        \n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        \n        return fig\n\n\ndef plot_bioelectric_gradient(field: np.ndarray, title: str = \"Bioelectric Field\") -> plt.Figure:\n    \"\"\"Plot bioelectric field with appropriate colormap.\"\"\"\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Use RdBu colormap for voltage data\n    im = ax.imshow(field, cmap='RdBu_r', aspect='auto')\n    \n    ax.set_title(title)\n    ax.set_xlabel('Lateral Position')\n    ax.set_ylabel('Anterior-Posterior Position')\n    \n    # Add colorbar with voltage units\n    cbar = plt.colorbar(im, ax=ax)\n    cbar.set_label('Voltage (mV)')\n    \n    return fig\n\n\ndef create_comparison_plot(fields: List[np.ndarray], titles: List[str]) -> plt.Figure:\n    \"\"\"Create comparison plot of multiple fields.\"\"\"\n    n_fields = len(fields)\n    cols = min(3, n_fields)\n    rows = (n_fields + cols - 1) // cols\n    \n    fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 5*rows))\n    \n    if n_fields == 1:\n        axes = [axes]\n    elif rows == 1:\n        axes = axes.flatten()\n    else:\n        axes = axes.flatten()\n    \n    for i, (field, title) in enumerate(zip(fields, titles)):\n        im = axes[i].imshow(field, cmap='viridis', aspect='auto')\n        axes[i].set_title(title)\n        plt.colorbar(im, ax=axes[i])\n    \n    # Hide unused subplots\n    for i in range(n_fields, len(axes)):\n        axes[i].set_visible(False)\n    \n    plt.tight_layout()\n    return fig\n\n\ndef save_animation(ani: animation.FuncAnimation, filename: str, fps: int = 10):\n    \"\"\"Save animation to file.\"\"\"\n    try:\n        writer = animation.PillowWriter(fps=fps)\n        ani.save(filename, writer=writer)\n    except Exception as e:\n        warnings.warn(f\"Failed to save animation: {e}\")\n        print(f\"To save animations, install pillow: pip install pillow\")